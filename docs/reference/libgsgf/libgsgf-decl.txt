<MACRO>
<NAME>GSGF_TYPE_NODE</NAME>
#define GSGF_TYPE_NODE                  (gsgf_node_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_NODE</NAME>
#define GSGF_NODE(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_NODE, GSGFNode))
</MACRO>
<MACRO>
<NAME>GSGF_NODE_CLASS</NAME>
#define GSGF_NODE_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_NODE, GSGFNodeClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_NODE</NAME>
#define GSGF_IS_NODE(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_NODE))
</MACRO>
<MACRO>
<NAME>GSGF_IS_NODE_CLASS</NAME>
#define GSGF_IS_NODE_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_NODE))
</MACRO>
<MACRO>
<NAME>GSGF_NODE_GET_CLASS</NAME>
#define GSGF_NODE_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_NODE, GSGFNodeClass))
</MACRO>
<STRUCT>
<NAME>GSGFNodeClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFNode</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFNodePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFNodeClass</NAME>
struct _GSGFNodeClass
{
        GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_node_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFNode</NAME>
struct _GSGFNode
{
        GObject parent_instance;

        /*< private >*/
        GSGFNodePrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_node_new</NAME>
<RETURNS>GSGFNode *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_node_add_property</NAME>
<RETURNS>struct _GSGFProperty *</RETURNS>
GSGFNode *self, const gchar *id, GError **error 
</FUNCTION>
<MACRO>
<NAME>GSGF_ERROR</NAME>
#define GSGF_ERROR gsgf_error_quark ()
</MACRO>
<ENUM>
<NAME>GSGFError</NAME>
typedef enum {
        GSGF_ERROR_NONE = 0,
        GSGF_ERROR_SYNTAX = 1,
        GSGF_ERROR_EMPTY_COLLECTION = 2,
        GSGF_ERROR_PROPERTY_EXISTS = 3
} GSGFError;
</ENUM>
<FUNCTION>
<NAME>gsgf_error_quark</NAME>
<RETURNS>GQuark </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_PROPERTY</NAME>
#define GSGF_TYPE_PROPERTY             (gsgf_property_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_PROPERTY</NAME>
#define GSGF_PROPERTY(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_PROPERTY, GSGFProperty))
</MACRO>
<MACRO>
<NAME>GSGF_PROPERTY_CLASS</NAME>
#define GSGF_PROPERTY_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_PROPERTY, GSGFPropertyClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_PROPERTY</NAME>
#define GSGF_IS_PROPERTY(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_PROPERTY))
</MACRO>
<MACRO>
<NAME>GSGF_IS_PROPERTY_CLASS</NAME>
#define GSGF_IS_PROPERTY_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_PROPERTY))
</MACRO>
<MACRO>
<NAME>GSGF_PROPERTY_GET_CLASS</NAME>
#define GSGF_PROPERTY_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_PROPERTY, GSGFPropertyClass))
</MACRO>
<STRUCT>
<NAME>GSGFPropertyClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFProperty</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFPropertyPrivate</NAME>
</STRUCT>
<ENUM>
<NAME>GSGFPropertyType</NAME>
typedef enum gsgf_property_type {
        GSGF_PROPERTY_TEXT,
        GSGF_PROPERTY_NUMBER,
        GSGF_PROPERTY_REAL
} GSGFPropertyType;
</ENUM>
<STRUCT>
<NAME>GSGFPropertyClass</NAME>
struct _GSGFPropertyClass
{
        GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_property_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFProperty</NAME>
struct _GSGFProperty
{
        GObject parent_instance;

        /*< private >*/
        GSGFPropertyPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_property_new</NAME>
<RETURNS>GSGFProperty *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_property_add_value</NAME>
<RETURNS>gboolean </RETURNS>
GSGFProperty *property, const gchar *text, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_property_get_values</NAME>
<RETURNS>GList *</RETURNS>
GSGFProperty *property 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_COLLECTION</NAME>
#define GSGF_TYPE_COLLECTION             (gsgf_collection_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_COLLECTION</NAME>
#define GSGF_COLLECTION(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_COLLECTION, GSGFCollection))
</MACRO>
<MACRO>
<NAME>GSGF_COLLECTION_CLASS</NAME>
#define GSGF_COLLECTION_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_COLLECTION, GSGFCollectionClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_COLLECTION</NAME>
#define GSGF_IS_COLLECTION(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_COLLECTION))
</MACRO>
<MACRO>
<NAME>GSGF_IS_COLLECTION_CLASS</NAME>
#define GSGF_IS_COLLECTION_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_COLLECTION))
</MACRO>
<MACRO>
<NAME>GSGF_COLLECTION_GET_CLASS</NAME>
#define GSGF_COLLECTION_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_COLLECTION, GSGFCollectionClass))
</MACRO>
<STRUCT>
<NAME>GSGFCollectionClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFCollection</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFCollectionPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFCollectionClass</NAME>
struct _GSGFCollectionClass
{
        GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_collection_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFCollection</NAME>
struct _GSGFCollection
{
        GObject parent_instance;

        /*< private >*/
        GSGFCollectionPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_collection_new</NAME>
<RETURNS>GSGFCollection *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_collection_parse_stream</NAME>
<RETURNS>GSGFCollection *</RETURNS>
GInputStream *stream, GCancellable *cancellable, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_collection_parse_file</NAME>
<RETURNS>GSGFCollection *</RETURNS>
GFile *file, GCancellable *cancellable, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_collection_add_game_tree</NAME>
<RETURNS>struct _GSGFGameTree *</RETURNS>
GSGFCollection *collection 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_collection_write_stream</NAME>
<RETURNS>gboolean </RETURNS>
const GSGFCollection *collection, GOutputStream *out, gsize *bytes_written, gboolean close_stream, GCancellable *cancellable, GError **error 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_GAME_TREE</NAME>
#define GSGF_TYPE_GAME_TREE             (gsgf_game_tree_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_GAME_TREE</NAME>
#define GSGF_GAME_TREE(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_GAME_TREE, GSGFGameTree))
</MACRO>
<MACRO>
<NAME>GSGF_GAME_TREE_CLASS</NAME>
#define GSGF_GAME_TREE_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_GAME_TREE, GSGFGameTreeClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_GAME_TREE</NAME>
#define GSGF_IS_GAME_TREE(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_GAME_TREE))
</MACRO>
<MACRO>
<NAME>GSGF_IS_GAME_TREE_CLASS</NAME>
#define GSGF_IS_GAME_TREE_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_GAME_TREE))
</MACRO>
<MACRO>
<NAME>GSGF_GAME_TREE_GET_CLASS</NAME>
#define GSGF_GAME_TREE_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_GAME_TREE, GSGFGameTreeClass))
</MACRO>
<STRUCT>
<NAME>GSGFGameTreeClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFGameTree</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFGameTreePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFGameTreeClass</NAME>
struct _GSGFGameTreeClass
{
        GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_game_tree_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFGameTree</NAME>
struct _GSGFGameTree
{
        GObject parent_instance;

        /*< private >*/
        GSGFGameTreePrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_game_tree_new</NAME>
<RETURNS>GSGFGameTree *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_game_tree_add_child</NAME>
<RETURNS>GSGFGameTree *</RETURNS>
GSGFGameTree *self 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_game_tree_get_parent</NAME>
<RETURNS>GSGFGameTree *</RETURNS>
const GSGFGameTree *self 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_game_tree_add_node</NAME>
<RETURNS>struct _GSGFNode *</RETURNS>
GSGFGameTree *self 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_game_tree_write_stream</NAME>
<RETURNS>gssize </RETURNS>
const GSGFCollection *collection, GOutputStream *out, GCancellable *cancellable, GError **error 
</FUNCTION>
<VARIABLE>
<NAME>filename</NAME>
extern char *filename;
</VARIABLE>
<VARIABLE>
<NAME>path</NAME>
extern char *path;
</VARIABLE>
<FUNCTION>
<NAME>test_collection</NAME>
<RETURNS>int </RETURNS>
GSGFCollection *collection, GError *error 
</FUNCTION>
<FUNCTION>
<NAME>expect_error</NAME>
<RETURNS>int </RETURNS>
GError *error, GError *expect 
</FUNCTION>
<FUNCTION>
<NAME>expect_error_conditional</NAME>
<RETURNS>int </RETURNS>
gboolean condition, const gchar *msg, GError *error, GError *expect 
</FUNCTION>
