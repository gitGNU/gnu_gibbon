<FUNCTION>
<NAME>libgsgf_init</NAME>
<RETURNS>void </RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_util_read_simpletext</NAME>
<RETURNS>gchar *</RETURNS>
const gchar *raw, const gchar **end, gchar delim 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_util_read_text</NAME>
<RETURNS>gchar *</RETURNS>
const gchar *raw, const gchar **end, gchar delim 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_NODE</NAME>
#define GSGF_TYPE_NODE                  (gsgf_node_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_NODE</NAME>
#define GSGF_NODE(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_NODE, GSGFNode))
</MACRO>
<MACRO>
<NAME>GSGF_NODE_CLASS</NAME>
#define GSGF_NODE_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_NODE, GSGFNodeClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_NODE</NAME>
#define GSGF_IS_NODE(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_NODE))
</MACRO>
<MACRO>
<NAME>GSGF_IS_NODE_CLASS</NAME>
#define GSGF_IS_NODE_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_NODE))
</MACRO>
<MACRO>
<NAME>GSGF_NODE_GET_CLASS</NAME>
#define GSGF_NODE_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_NODE, GSGFNodeClass))
</MACRO>
<STRUCT>
<NAME>GSGFNodeClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFNode</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFNodePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFNodeClass</NAME>
struct _GSGFNodeClass
{
        GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_node_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFNode</NAME>
struct _GSGFNode
{
        GObject parent_instance;

        /*< private >*/
        GSGFNodePrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_node_add_property</NAME>
<RETURNS>struct _GSGFProperty *</RETURNS>
GSGFNode *self, const gchar *id, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_node_get_property</NAME>
<RETURNS>struct _GSGFProperty *</RETURNS>
GSGFNode *self, const gchar *id 
</FUNCTION>
<MACRO>
<NAME>GSGF_ERROR</NAME>
#define GSGF_ERROR gsgf_error_quark ()
</MACRO>
<ENUM>
<NAME>GSGFError</NAME>
typedef enum {
        GSGF_ERROR_NONE = 0,
        GSGF_ERROR_FLAVOR_UNSUPPORTED = 1,
        GSGF_ERROR_FLAVOR_MISMATCH = 2,
        GSGF_ERROR_SYNTAX = 3,
        GSGF_ERROR_EMPTY_COLLECTION = 4,
        GSGF_ERROR_PROPERTY_EXISTS = 5,
        GSGF_ERROR_EMPTY_PROPERTY = 6
} GSGFError;
</ENUM>
<FUNCTION>
<NAME>gsgf_error_quark</NAME>
<RETURNS>GQuark </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_FLAVOR</NAME>
#define GSGF_TYPE_FLAVOR             (gsgf_flavor_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_FLAVOR</NAME>
#define GSGF_FLAVOR(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_FLAVOR, GSGFFlavor))
</MACRO>
<MACRO>
<NAME>GSGF_FLAVOR_CLASS</NAME>
#define GSGF_FLAVOR_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_FLAVOR, GSGFFlavorClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_FLAVOR</NAME>
#define GSGF_IS_FLAVOR(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_FLAVOR))
</MACRO>
<MACRO>
<NAME>GSGF_IS_FLAVOR_CLASS</NAME>
#define GSGF_IS_FLAVOR_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_FLAVOR))
</MACRO>
<MACRO>
<NAME>GSGF_FLAVOR_GET_CLASS</NAME>
#define GSGF_FLAVOR_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_FLAVOR, GSGFFlavorClass))
</MACRO>
<STRUCT>
<NAME>GSGFFlavorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFFlavor</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFFlavorPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFFlavorClass</NAME>
struct _GSGFFlavorClass
{
        GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_flavor_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFFlavor</NAME>
struct _GSGFFlavor
{
        GObject parent_instance;

        /*< private >*/
        GSGFFlavorPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_flavor_new</NAME>
<RETURNS>GSGFFlavor*</RETURNS>
const gchar *id, const gchar *name 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_PROPERTY</NAME>
#define GSGF_TYPE_PROPERTY             (gsgf_property_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_PROPERTY</NAME>
#define GSGF_PROPERTY(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_PROPERTY, GSGFProperty))
</MACRO>
<MACRO>
<NAME>GSGF_PROPERTY_CLASS</NAME>
#define GSGF_PROPERTY_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_PROPERTY, GSGFPropertyClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_PROPERTY</NAME>
#define GSGF_IS_PROPERTY(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_PROPERTY))
</MACRO>
<MACRO>
<NAME>GSGF_IS_PROPERTY_CLASS</NAME>
#define GSGF_IS_PROPERTY_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_PROPERTY))
</MACRO>
<MACRO>
<NAME>GSGF_PROPERTY_GET_CLASS</NAME>
#define GSGF_PROPERTY_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_PROPERTY, GSGFPropertyClass))
</MACRO>
<STRUCT>
<NAME>GSGFPropertyClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFProperty</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFPropertyPrivate</NAME>
</STRUCT>
<ENUM>
<NAME>GSGFPropertyType</NAME>
typedef enum gsgf_property_type {
        GSGF_PROPERTY_TEXT,
        GSGF_PROPERTY_NUMBER,
        GSGF_PROPERTY_REAL
} GSGFPropertyType;
</ENUM>
<STRUCT>
<NAME>GSGFPropertyClass</NAME>
struct _GSGFPropertyClass
{
        GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_property_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFProperty</NAME>
struct _GSGFProperty
{
        GObject parent_instance;

        /*< private >*/
        GSGFPropertyPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_property_get_raw</NAME>
<RETURNS>const gchar *</RETURNS>
const GSGFProperty* property, gsize i 
</FUNCTION>
<USER_FUNCTION>
<NAME>GSGFPropertyTextUpdater</NAME>
<RETURNS>gboolean </RETURNS>
GSGFProperty *property,
                                             const gchar *text, GError **error
</USER_FUNCTION>
<STRUCT>
<NAME>GSGFPropertyHandler</NAME>
struct _GSGFPropertyHandler {
        GSGFPropertyTextUpdater text_updater;
};
</STRUCT>
<STRUCT>
<NAME>GSGFPropertyHandler</NAME>
</STRUCT>
<FUNCTION>
<NAME>gsgf_property_handler_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_PROPERTY_HANDLER</NAME>
#define GSGF_TYPE_PROPERTY_HANDLER (gsgf_property_handler_get_type())
</MACRO>
<FUNCTION>
<NAME>gsgf_property_handler_new</NAME>
<RETURNS>GSGFPropertyHandler*</RETURNS>
const gchar *id, const gchar *name 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_property_handler_copy</NAME>
<RETURNS>GSGFPropertyHandler*</RETURNS>
const GSGFPropertyHandler * 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_property_handler_destroy</NAME>
<RETURNS>void </RETURNS>
GSGFPropertyHandler * 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_COLLECTION</NAME>
#define GSGF_TYPE_COLLECTION             (gsgf_collection_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_COLLECTION</NAME>
#define GSGF_COLLECTION(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_COLLECTION, GSGFCollection))
</MACRO>
<MACRO>
<NAME>GSGF_COLLECTION_CLASS</NAME>
#define GSGF_COLLECTION_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_COLLECTION, GSGFCollectionClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_COLLECTION</NAME>
#define GSGF_IS_COLLECTION(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_COLLECTION))
</MACRO>
<MACRO>
<NAME>GSGF_IS_COLLECTION_CLASS</NAME>
#define GSGF_IS_COLLECTION_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_COLLECTION))
</MACRO>
<MACRO>
<NAME>GSGF_COLLECTION_GET_CLASS</NAME>
#define GSGF_COLLECTION_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_COLLECTION, GSGFCollectionClass))
</MACRO>
<STRUCT>
<NAME>GSGFCollectionClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFCollection</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFCollectionPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFCollectionClass</NAME>
struct _GSGFCollectionClass
{
        GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_collection_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFCollection</NAME>
struct _GSGFCollection
{
        GObject parent_instance;

        /*< private >*/
        GSGFCollectionPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_collection_new</NAME>
<RETURNS>GSGFCollection *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_collection_parse_stream</NAME>
<RETURNS>GSGFCollection *</RETURNS>
GInputStream *stream, GCancellable *cancellable, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_collection_parse_file</NAME>
<RETURNS>GSGFCollection *</RETURNS>
GFile *file, GCancellable *cancellable, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_collection_add_game_tree</NAME>
<RETURNS>struct _GSGFGameTree *</RETURNS>
GSGFCollection *collection 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_collection_write_stream</NAME>
<RETURNS>gboolean </RETURNS>
const GSGFCollection *collection, GOutputStream *out, gsize *bytes_written, gboolean close_stream, GCancellable *cancellable, GError **error 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_GAME_TREE</NAME>
#define GSGF_TYPE_GAME_TREE             (gsgf_game_tree_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_GAME_TREE</NAME>
#define GSGF_GAME_TREE(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_GAME_TREE, GSGFGameTree))
</MACRO>
<MACRO>
<NAME>GSGF_GAME_TREE_CLASS</NAME>
#define GSGF_GAME_TREE_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_GAME_TREE, GSGFGameTreeClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_GAME_TREE</NAME>
#define GSGF_IS_GAME_TREE(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_GAME_TREE))
</MACRO>
<MACRO>
<NAME>GSGF_IS_GAME_TREE_CLASS</NAME>
#define GSGF_IS_GAME_TREE_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_GAME_TREE))
</MACRO>
<MACRO>
<NAME>GSGF_GAME_TREE_GET_CLASS</NAME>
#define GSGF_GAME_TREE_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_GAME_TREE, GSGFGameTreeClass))
</MACRO>
<STRUCT>
<NAME>GSGFGameTreeClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFGameTree</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFGameTreePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFGameTreeClass</NAME>
struct _GSGFGameTreeClass
{
        GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_game_tree_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFGameTree</NAME>
struct _GSGFGameTree
{
        GObject parent_instance;

        /*< private >*/
        GSGFGameTreePrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_game_tree_add_child</NAME>
<RETURNS>GSGFGameTree *</RETURNS>
GSGFGameTree *self 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_game_tree_get_parent</NAME>
<RETURNS>GSGFGameTree *</RETURNS>
const GSGFGameTree *self 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_game_tree_add_node</NAME>
<RETURNS>struct _GSGFNode *</RETURNS>
GSGFGameTree *self 
</FUNCTION>
<VARIABLE>
<NAME>filename</NAME>
extern char *filename;
</VARIABLE>
<VARIABLE>
<NAME>path</NAME>
extern char *path;
</VARIABLE>
<FUNCTION>
<NAME>test_collection</NAME>
<RETURNS>int </RETURNS>
GSGFCollection *collection, GError *error 
</FUNCTION>
<FUNCTION>
<NAME>expect_error</NAME>
<RETURNS>int </RETURNS>
GError *error, GError *expect 
</FUNCTION>
<FUNCTION>
<NAME>expect_error_conditional</NAME>
<RETURNS>int </RETURNS>
gboolean condition, const gchar *msg, GError *error, GError *expect 
</FUNCTION>
<FUNCTION>
<NAME>g_memory_stream_get_string</NAME>
<RETURNS>gchar *</RETURNS>
const GMemoryOutputStream *stream 
</FUNCTION>
