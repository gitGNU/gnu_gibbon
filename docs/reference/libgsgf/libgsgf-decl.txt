<FUNCTION>
<NAME>gsgf_util_read_simple_text</NAME>
<RETURNS>gchar *</RETURNS>
const gchar *raw, const gchar **end, gchar delim 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_util_read_text</NAME>
<RETURNS>gchar *</RETURNS>
const gchar *raw, const gchar **end, gchar delim 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_MOVE</NAME>
#define GSGF_TYPE_MOVE             (gsgf_move_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_MOVE</NAME>
#define GSGF_MOVE(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_MOVE, GSGFMove))
</MACRO>
<MACRO>
<NAME>GSGF_MOVE_CLASS</NAME>
#define GSGF_MOVE_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_MOVE, GSGFMoveClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_MOVE</NAME>
#define GSGF_IS_MOVE(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_MOVE))
</MACRO>
<MACRO>
<NAME>GSGF_IS_MOVE_CLASS</NAME>
#define GSGF_IS_MOVE_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_MOVE))
</MACRO>
<MACRO>
<NAME>GSGF_MOVE_GET_CLASS</NAME>
#define GSGF_MOVE_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_MOVE, GSGFMoveClass))
</MACRO>
<STRUCT>
<NAME>GSGFMoveClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFMove</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFMoveClass</NAME>
struct _GSGFMoveClass
{
        GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_move_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFMove</NAME>
struct _GSGFMove
{
        GObject parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_move_new</NAME>
<RETURNS>GSGFMove *</RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_NODE</NAME>
#define GSGF_TYPE_NODE                  (gsgf_node_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_NODE</NAME>
#define GSGF_NODE(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_NODE, GSGFNode))
</MACRO>
<MACRO>
<NAME>GSGF_NODE_CLASS</NAME>
#define GSGF_NODE_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_NODE, GSGFNodeClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_NODE</NAME>
#define GSGF_IS_NODE(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_NODE))
</MACRO>
<MACRO>
<NAME>GSGF_IS_NODE_CLASS</NAME>
#define GSGF_IS_NODE_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_NODE))
</MACRO>
<MACRO>
<NAME>GSGF_NODE_GET_CLASS</NAME>
#define GSGF_NODE_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_NODE, GSGFNodeClass))
</MACRO>
<STRUCT>
<NAME>GSGFNodeClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFNode</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFNodePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFNodeClass</NAME>
struct _GSGFNodeClass
{
        GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_node_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFNode</NAME>
struct _GSGFNode
{
        GObject parent_instance;

        /*< private >*/
        GSGFNodePrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_node_add_property</NAME>
<RETURNS>struct _GSGFProperty *</RETURNS>
GSGFNode *self, const gchar *id, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_node_get_property</NAME>
<RETURNS>struct _GSGFProperty *</RETURNS>
const GSGFNode *self, const gchar *id 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_node_get_property_ids</NAME>
<RETURNS>GList *</RETURNS>
const GSGFNode *self 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_node_remove_property</NAME>
<RETURNS>void </RETURNS>
GSGFNode *self, const gchar *id 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_node_get_property_cooked</NAME>
<RETURNS>GSGFCookedValue *</RETURNS>
const GSGFNode *self, const gchar *id 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_node_get_previous_node</NAME>
<RETURNS>GSGFNode *</RETURNS>
const GSGFNode *self 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_REAL</NAME>
#define GSGF_TYPE_REAL             (gsgf_real_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_REAL</NAME>
#define GSGF_REAL(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_REAL, GSGFReal))
</MACRO>
<MACRO>
<NAME>GSGF_REAL_CLASS</NAME>
#define GSGF_REAL_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_REAL, GSGFRealClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_REAL</NAME>
#define GSGF_IS_REAL(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_REAL))
</MACRO>
<MACRO>
<NAME>GSGF_IS_REAL_CLASS</NAME>
#define GSGF_IS_REAL_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_REAL))
</MACRO>
<MACRO>
<NAME>GSGF_REAL_GET_CLASS</NAME>
#define GSGF_REAL_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_REAL, GSGFRealClass))
</MACRO>
<STRUCT>
<NAME>GSGFRealClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFReal</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFRealPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFRealClass</NAME>
struct _GSGFRealClass
{
        GSGFCookedValueClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_real_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFReal</NAME>
struct _GSGFReal
{
        GSGFCookedValue parent_instance;

        /*< private >*/
        GSGFRealPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_real_new</NAME>
<RETURNS>GSGFReal*</RETURNS>
gdouble value 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_real_set_value</NAME>
<RETURNS>void </RETURNS>
GSGFReal *self, gdouble value 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_real_get_value</NAME>
<RETURNS>gdouble </RETURNS>
const GSGFReal *self 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_TEXT</NAME>
#define GSGF_TYPE_TEXT             (gsgf_text_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_TEXT</NAME>
#define GSGF_TEXT(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_TEXT, GSGFText))
</MACRO>
<MACRO>
<NAME>GSGF_TEXT_CLASS</NAME>
#define GSGF_TEXT_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_TEXT, GSGFTextClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_TEXT</NAME>
#define GSGF_IS_TEXT(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_TEXT))
</MACRO>
<MACRO>
<NAME>GSGF_IS_TEXT_CLASS</NAME>
#define GSGF_IS_TEXT_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_TEXT))
</MACRO>
<MACRO>
<NAME>GSGF_TEXT_GET_CLASS</NAME>
#define GSGF_TEXT_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_TEXT, GSGFTextClass))
</MACRO>
<STRUCT>
<NAME>GSGFTextClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFText</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFTextPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFTextClass</NAME>
struct _GSGFTextClass
{
        GSGFCookedValueClass parent_class;

        void (*set_value) (GSGFText *self, const gchar *value, gboolean copy);
        gchar * (*get_value) (const GSGFText *self);
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_text_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFText</NAME>
struct _GSGFText
{
        GSGFCookedValue parent_instance;

        /*< private >*/
        GSGFTextPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_text_new</NAME>
<RETURNS>GSGFText*</RETURNS>
const gchar *value 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_text_new_from_raw</NAME>
<RETURNS>GSGFCookedValue*</RETURNS>
const GSGFRaw *raw, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_text_set_value</NAME>
<RETURNS>void </RETURNS>
GSGFText *self, const gchar *value, gboolean copy 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_text_get_value</NAME>
<RETURNS>gchar *</RETURNS>
const GSGFText *self 
</FUNCTION>
<MACRO>
<NAME>GSGF_ERROR</NAME>
#define GSGF_ERROR gsgf_error_quark ()
</MACRO>
<ENUM>
<NAME>GSGFError</NAME>
typedef enum {
        GSGF_ERROR_NONE = 0,
        GSGF_ERROR_FLAVOR_UNSUPPORTED = 1,
        GSGF_ERROR_FLAVOR_MISMATCH = 2,
        GSGF_ERROR_SYNTAX = 3,
        GSGF_ERROR_EMPTY_COLLECTION = 4,
        GSGF_ERROR_PROPERTY_EXISTS = 5,
        GSGF_ERROR_EMPTY_PROPERTY = 6,
        GSGF_ERROR_INTERNAL_ERROR = 7,
        GSGF_ERROR_INVALID_NUMBER = 8,
        GSGF_ERROR_LIST_TOO_LONG = 9,
        GSGF_ERROR_SEMANTIC_ERROR = 10
} GSGFError;
</ENUM>
<FUNCTION>
<NAME>gsgf_error_quark</NAME>
<RETURNS>GQuark </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_COMPOSE</NAME>
#define GSGF_TYPE_COMPOSE             (gsgf_compose_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_COMPOSE</NAME>
#define GSGF_COMPOSE(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_COMPOSE, GSGFCompose))
</MACRO>
<MACRO>
<NAME>GSGF_COMPOSE_CLASS</NAME>
#define GSGF_COMPOSE_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_COMPOSE, GSGFComposeClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_COMPOSE</NAME>
#define GSGF_IS_COMPOSE(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_COMPOSE))
</MACRO>
<MACRO>
<NAME>GSGF_IS_COMPOSE_CLASS</NAME>
#define GSGF_IS_COMPOSE_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_COMPOSE))
</MACRO>
<MACRO>
<NAME>GSGF_COMPOSE_GET_CLASS</NAME>
#define GSGF_COMPOSE_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_COMPOSE, GSGFComposeClass))
</MACRO>
<STRUCT>
<NAME>GSGFComposeClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFCompose</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFComposePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFComposeClass</NAME>
struct _GSGFComposeClass
{
        GSGFCookedValueClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_compose_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFCompose</NAME>
struct _GSGFCompose
{
        GSGFCookedValue parent_instance;

        /*< private >*/
        GSGFComposePrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_compose_new</NAME>
<RETURNS>GSGFCompose *</RETURNS>
GSGFCookedValue *val1, ... 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_compose_get_number_of_values</NAME>
<RETURNS>gsize </RETURNS>
const GSGFCompose *self 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_compose_set_value</NAME>
<RETURNS>void </RETURNS>
GSGFCompose *self, GSGFCookedValue *value, gsize i 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_compose_get_value</NAME>
<RETURNS>GSGFCookedValue *</RETURNS>
const GSGFCompose *self, gsize i 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_SIMPLE_TEXT</NAME>
#define GSGF_TYPE_SIMPLE_TEXT             (gsgf_simple_text_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_SIMPLE_TEXT</NAME>
#define GSGF_SIMPLE_TEXT(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_SIMPLE_TEXT, GSGFSimpleText))
</MACRO>
<MACRO>
<NAME>GSGF_SIMPLE_TEXT_CLASS</NAME>
#define GSGF_SIMPLE_TEXT_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_SIMPLE_TEXT, GSGFSimpleTextClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_SIMPLE_TEXT</NAME>
#define GSGF_IS_SIMPLE_TEXT(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_SIMPLE_TEXT))
</MACRO>
<MACRO>
<NAME>GSGF_IS_SIMPLE_TEXT_CLASS</NAME>
#define GSGF_IS_SIMPLE_TEXT_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_SIMPLE_TEXT))
</MACRO>
<MACRO>
<NAME>GSGF_SIMPLE_TEXT_GET_CLASS</NAME>
#define GSGF_SIMPLE_TEXT_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_SIMPLE_TEXT, GSGFSimpleTextClass))
</MACRO>
<STRUCT>
<NAME>GSGFSimpleTextClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFSimpleText</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFSimpleTextPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFSimpleTextClass</NAME>
struct _GSGFSimpleTextClass
{
        GSGFTextClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_simple_text_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFSimpleText</NAME>
struct _GSGFSimpleText
{
        GSGFText parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_simple_text_new</NAME>
<RETURNS>GSGFSimpleText*</RETURNS>
const gchar *value 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_simple_text_new_from_raw</NAME>
<RETURNS>GSGFCookedValue*</RETURNS>
const GSGFRaw *raw, GError **error 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_FLAVOR</NAME>
#define GSGF_TYPE_FLAVOR             (gsgf_flavor_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_FLAVOR</NAME>
#define GSGF_FLAVOR(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_FLAVOR, GSGFFlavor))
</MACRO>
<MACRO>
<NAME>GSGF_FLAVOR_CLASS</NAME>
#define GSGF_FLAVOR_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_FLAVOR, GSGFFlavorClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_FLAVOR</NAME>
#define GSGF_IS_FLAVOR(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_FLAVOR))
</MACRO>
<MACRO>
<NAME>GSGF_IS_FLAVOR_CLASS</NAME>
#define GSGF_IS_FLAVOR_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_FLAVOR))
</MACRO>
<MACRO>
<NAME>GSGF_FLAVOR_GET_CLASS</NAME>
#define GSGF_FLAVOR_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_FLAVOR, GSGFFlavorClass))
</MACRO>
<STRUCT>
<NAME>GSGFFlavorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFFlavor</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFFlavorClass</NAME>
struct _GSGFFlavorClass
{
        GObjectClass parent_class;

        gboolean (*get_cooked_value) (const GSGFFlavor *flavor,
                                      const struct _GSGFProperty *property,
                                      const struct _GSGFRaw *raw,
                                      struct _GSGFCookedValue **cooked,
                                      GError **error);
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_flavor_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFFlavor</NAME>
struct _GSGFFlavor
{
        GObject parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_flavor_new</NAME>
<RETURNS>GSGFFlavor *</RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_flavor_get_cooked_value</NAME>
<RETURNS>gboolean </RETURNS>
const GSGFFlavor *flavor, const struct _GSGFProperty *property, const struct _GSGFRaw *raw, struct _GSGFCookedValue **cooked, GError **error 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_PROPERTY</NAME>
#define GSGF_TYPE_PROPERTY             (gsgf_property_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_PROPERTY</NAME>
#define GSGF_PROPERTY(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_PROPERTY, GSGFProperty))
</MACRO>
<MACRO>
<NAME>GSGF_PROPERTY_CLASS</NAME>
#define GSGF_PROPERTY_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_PROPERTY, GSGFPropertyClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_PROPERTY</NAME>
#define GSGF_IS_PROPERTY(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_PROPERTY))
</MACRO>
<MACRO>
<NAME>GSGF_IS_PROPERTY_CLASS</NAME>
#define GSGF_IS_PROPERTY_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_PROPERTY))
</MACRO>
<MACRO>
<NAME>GSGF_PROPERTY_GET_CLASS</NAME>
#define GSGF_PROPERTY_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_PROPERTY, GSGFPropertyClass))
</MACRO>
<STRUCT>
<NAME>GSGFPropertyClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFProperty</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFPropertyPrivate</NAME>
</STRUCT>
<ENUM>
<NAME>GSGFPropertyType</NAME>
typedef enum gsgf_property_type {
        GSGF_PROPERTY_TEXT,
        GSGF_PROPERTY_NUMBER,
        GSGF_PROPERTY_REAL
} GSGFPropertyType;
</ENUM>
<STRUCT>
<NAME>GSGFPropertyClass</NAME>
struct _GSGFPropertyClass
{
        GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_property_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFProperty</NAME>
struct _GSGFProperty
{
        GObject parent_instance;

        /*< private >*/
        GSGFPropertyPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_property_get_id</NAME>
<RETURNS>const gchar *</RETURNS>
const GSGFProperty *property 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_property_get_node</NAME>
<RETURNS>GSGFNode *</RETURNS>
const GSGFProperty *property 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_property_get_value</NAME>
<RETURNS>GSGFCookedValue *</RETURNS>
const GSGFProperty* property 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_COLLECTION</NAME>
#define GSGF_TYPE_COLLECTION             (gsgf_collection_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_COLLECTION</NAME>
#define GSGF_COLLECTION(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_COLLECTION, GSGFCollection))
</MACRO>
<MACRO>
<NAME>GSGF_COLLECTION_CLASS</NAME>
#define GSGF_COLLECTION_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_COLLECTION, GSGFCollectionClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_COLLECTION</NAME>
#define GSGF_IS_COLLECTION(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_COLLECTION))
</MACRO>
<MACRO>
<NAME>GSGF_IS_COLLECTION_CLASS</NAME>
#define GSGF_IS_COLLECTION_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_COLLECTION))
</MACRO>
<MACRO>
<NAME>GSGF_COLLECTION_GET_CLASS</NAME>
#define GSGF_COLLECTION_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_COLLECTION, GSGFCollectionClass))
</MACRO>
<STRUCT>
<NAME>GSGFCollectionClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFCollection</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFCollectionPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFCollectionClass</NAME>
struct _GSGFCollectionClass
{
        GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_collection_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFCollection</NAME>
struct _GSGFCollection
{
        GObject parent_instance;

        /*< private >*/
        GSGFCollectionPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_collection_new</NAME>
<RETURNS>GSGFCollection *</RETURNS>
 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_collection_parse_stream</NAME>
<RETURNS>GSGFCollection *</RETURNS>
GInputStream *stream, GCancellable *cancellable, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_collection_parse_file</NAME>
<RETURNS>GSGFCollection *</RETURNS>
GFile *file, GCancellable *cancellable, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_collection_add_game_tree</NAME>
<RETURNS>struct _GSGFGameTree *</RETURNS>
GSGFCollection *collection 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_collection_write_stream</NAME>
<RETURNS>gboolean </RETURNS>
const GSGFCollection *collection, GOutputStream *out, gsize *bytes_written, gboolean close_stream, GCancellable *cancellable, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_collection_get_game_trees</NAME>
<RETURNS>GList *</RETURNS>
const GSGFCollection *collection 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_FLAVOR_BACKGAMMON</NAME>
#define GSGF_TYPE_FLAVOR_BACKGAMMON  (gsgf_flavor_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_FLAVOR_BACKGAMMON</NAME>
#define GSGF_FLAVOR_BACKGAMMON(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_FLAVOR_BACKGAMMON, GSGFFlavorBackgammon))
</MACRO>
<MACRO>
<NAME>GSGF_FLAVOR_BACKGAMMON_CLASS</NAME>
#define GSGF_FLAVOR_BACKGAMMON_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_FLAVOR_BACKGAMMON, GSGFFlavorBackgammonClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_FLAVOR_BACKGAMMON</NAME>
#define GSGF_IS_FLAVOR_BACKGAMMON(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_FLAVOR_BACKGAMMON))
</MACRO>
<MACRO>
<NAME>GSGF_IS_FLAVOR_BACKGAMMON_CLASS</NAME>
#define GSGF_IS_FLAVOR_BACKGAMMON_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_FLAVOR_BACKGAMMON))
</MACRO>
<MACRO>
<NAME>GSGF_FLAVOR_BACKGAMMON_GET_CLASS</NAME>
#define GSGF_FLAVOR_BACKGAMMON_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_FLAVOR_BACKGAMMON, GSGFFlavorBackgammonClass))
</MACRO>
<STRUCT>
<NAME>GSGFFlavorBackgammonClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFFlavorBackgammon</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFFlavorBackgammonClass</NAME>
struct _GSGFFlavorBackgammonClass
{
        GSGFFlavorClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_flavor_backgammon_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFFlavorBackgammon</NAME>
struct _GSGFFlavorBackgammon
{
        GSGFFlavor parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_flavor_backgammon_new</NAME>
<RETURNS>GSGFFlavorBackgammon *</RETURNS>
void 
</FUNCTION>
<USER_FUNCTION>
<NAME>GSGFCookedConstructor</NAME>
<RETURNS>GSGFCookedValue *</RETURNS>
const GSGFRaw *raw, GError **error
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GSGFCookedConstraint</NAME>
<RETURNS>gboolean </RETURNS>
const GSGFCookedValue *cooked,
                                          const GSGFRaw *raw,
                                          const GSGFProperty *property,
                                          GError **error
</USER_FUNCTION>
<STRUCT>
<NAME>GSGFFlavorTypeDef</NAME>
struct _GSGFFlavorTypeDef {
        GSGFCookedConstructor constructor;
        GSGFCookedConstraint constraints[];
};
</STRUCT>
<STRUCT>
<NAME>GSGFFlavorTypeDef</NAME>
</STRUCT>
<FUNCTION>
<NAME>gsgf_constraint_is_positive_number</NAME>
<RETURNS>gboolean </RETURNS>
const GSGFCookedValue *cooked, const GSGFRaw *raw, const GSGFProperty *property, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_constraint_is_root_property</NAME>
<RETURNS>gboolean </RETURNS>
const GSGFCookedValue *cooked, const GSGFRaw *raw, const GSGFProperty *property, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_constraint_is_single_value</NAME>
<RETURNS>gboolean </RETURNS>
const GSGFCookedValue *cooked, const GSGFRaw *raw, const GSGFProperty *property, GError **error 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_RAW</NAME>
#define GSGF_TYPE_RAW             (gsgf_raw_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_RAW</NAME>
#define GSGF_RAW(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_RAW, GSGFRaw))
</MACRO>
<MACRO>
<NAME>GSGF_RAW_CLASS</NAME>
#define GSGF_RAW_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_RAW, GSGFRawClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_RAW</NAME>
#define GSGF_IS_RAW(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_RAW))
</MACRO>
<MACRO>
<NAME>GSGF_IS_RAW_CLASS</NAME>
#define GSGF_IS_RAW_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_RAW))
</MACRO>
<MACRO>
<NAME>GSGF_RAW_GET_CLASS</NAME>
#define GSGF_RAW_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_RAW, GSGFRawClass))
</MACRO>
<STRUCT>
<NAME>GSGFRawClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFRaw</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFRawPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFRawClass</NAME>
struct _GSGFRawClass
{
        GSGFCookedValueClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_raw_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFRaw</NAME>
struct _GSGFRaw
{
        GSGFCookedValue parent_instance;

        /*< private >*/
        GSGFRawPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_raw_new</NAME>
<RETURNS>GSGFRaw*</RETURNS>
const gchar *value 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_raw_get_number_of_values</NAME>
<RETURNS>gsize </RETURNS>
const GSGFRaw *raw 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_raw_get_value</NAME>
<RETURNS>gchar *</RETURNS>
const GSGFRaw *self, gsize i 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_NUMBER</NAME>
#define GSGF_TYPE_NUMBER             (gsgf_number_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_NUMBER</NAME>
#define GSGF_NUMBER(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_NUMBER, GSGFNumber))
</MACRO>
<MACRO>
<NAME>GSGF_NUMBER_CLASS</NAME>
#define GSGF_NUMBER_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_NUMBER, GSGFNumberClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_NUMBER</NAME>
#define GSGF_IS_NUMBER(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_NUMBER))
</MACRO>
<MACRO>
<NAME>GSGF_IS_NUMBER_CLASS</NAME>
#define GSGF_IS_NUMBER_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_NUMBER))
</MACRO>
<MACRO>
<NAME>GSGF_NUMBER_GET_CLASS</NAME>
#define GSGF_NUMBER_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_NUMBER, GSGFNumberClass))
</MACRO>
<STRUCT>
<NAME>GSGFNumberClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFNumber</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFNumberPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFNumberClass</NAME>
struct _GSGFNumberClass
{
        GSGFCookedValueClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_number_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFNumber</NAME>
struct _GSGFNumber
{
        GSGFCookedValue parent_instance;

        /*< private >*/
        GSGFNumberPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_number_new</NAME>
<RETURNS>GSGFNumber *</RETURNS>
gint64 value 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_number_new_from_raw</NAME>
<RETURNS>GSGFCookedValue *</RETURNS>
const GSGFRaw* raw, GError **error 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_number_set_value</NAME>
<RETURNS>void </RETURNS>
GSGFNumber *self, gint64 value 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_number_get_value</NAME>
<RETURNS>gint64 </RETURNS>
const GSGFNumber *self 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_COOKED_VALUE</NAME>
#define GSGF_TYPE_COOKED_VALUE             (gsgf_cooked_value_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_COOKED_VALUE</NAME>
#define GSGF_COOKED_VALUE(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_COOKED_VALUE, GSGFCookedValue))
</MACRO>
<MACRO>
<NAME>GSGF_COOKED_VALUE_CLASS</NAME>
#define GSGF_COOKED_VALUE_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_COOKED_VALUE, GSGFCookedValueClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_COOKED_VALUE</NAME>
#define GSGF_IS_COOKED_VALUE(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_COOKED_VALUE))
</MACRO>
<MACRO>
<NAME>GSGF_IS_COOKED_VALUE_CLASS</NAME>
#define GSGF_IS_COOKED_VALUE_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_COOKED_VALUE))
</MACRO>
<MACRO>
<NAME>GSGF_COOKED_VALUE_GET_CLASS</NAME>
#define GSGF_COOKED_VALUE_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_COOKED_VALUE, GSGFCookedValueClass))
</MACRO>
<STRUCT>
<NAME>GSGFCookedValueClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFCookedValue</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFCookedValuePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFCookedValueClass</NAME>
struct _GSGFCookedValueClass
{
        GObjectClass parent_class;

        gboolean (*write_stream) (const GSGFCookedValue *self, GOutputStream *out,
                                  gsize *bytes_written,
                                  GCancellable *cancellable, GError **error);
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_cooked_value_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFCookedValue</NAME>
struct _GSGFCookedValue
{
        GObject parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_cooked_value_write_stream</NAME>
<RETURNS>gboolean </RETURNS>
const GSGFCookedValue *self, GOutputStream *out, gsize *bytes_written, GCancellable *cancellable, GError **error 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_GAME_TREE</NAME>
#define GSGF_TYPE_GAME_TREE             (gsgf_game_tree_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_GAME_TREE</NAME>
#define GSGF_GAME_TREE(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_GAME_TREE, GSGFGameTree))
</MACRO>
<MACRO>
<NAME>GSGF_GAME_TREE_CLASS</NAME>
#define GSGF_GAME_TREE_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_GAME_TREE, GSGFGameTreeClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_GAME_TREE</NAME>
#define GSGF_IS_GAME_TREE(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_GAME_TREE))
</MACRO>
<MACRO>
<NAME>GSGF_IS_GAME_TREE_CLASS</NAME>
#define GSGF_IS_GAME_TREE_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_GAME_TREE))
</MACRO>
<MACRO>
<NAME>GSGF_GAME_TREE_GET_CLASS</NAME>
#define GSGF_GAME_TREE_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_GAME_TREE, GSGFGameTreeClass))
</MACRO>
<STRUCT>
<NAME>GSGFGameTreeClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFGameTree</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFGameTreePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFGameTreeClass</NAME>
struct _GSGFGameTreeClass
{
        GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_game_tree_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFGameTree</NAME>
struct _GSGFGameTree
{
        GObject parent_instance;

        /*< private >*/
        GSGFGameTreePrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_game_tree_add_child</NAME>
<RETURNS>GSGFGameTree *</RETURNS>
GSGFGameTree *self 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_game_tree_get_parent</NAME>
<RETURNS>GSGFGameTree *</RETURNS>
const GSGFGameTree *self 
</FUNCTION>
<FUNCTION>
<NAME>gsgf_game_tree_add_node</NAME>
<RETURNS>struct _GSGFNode *</RETURNS>
GSGFGameTree *self 
</FUNCTION>
<MACRO>
<NAME>GSGF_TYPE_MOVE_BACKGAMMON</NAME>
#define GSGF_TYPE_MOVE_BACKGAMMON  (gsgf_move_get_type ())
</MACRO>
<MACRO>
<NAME>GSGF_MOVE_BACKGAMMON</NAME>
#define GSGF_MOVE_BACKGAMMON(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GSGF_TYPE_MOVE_BACKGAMMON, GSGFMoveBackgammon))
</MACRO>
<MACRO>
<NAME>GSGF_MOVE_BACKGAMMON_CLASS</NAME>
#define GSGF_MOVE_BACKGAMMON_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GSGF_TYPE_MOVE_BACKGAMMON, GSGFMoveBackgammonClass))
</MACRO>
<MACRO>
<NAME>GSGF_IS_MOVE_BACKGAMMON</NAME>
#define GSGF_IS_MOVE_BACKGAMMON(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GSGF_TYPE_MOVE_BACKGAMMON))
</MACRO>
<MACRO>
<NAME>GSGF_IS_MOVE_BACKGAMMON_CLASS</NAME>
#define GSGF_IS_MOVE_BACKGAMMON_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GSGF_TYPE_MOVE_BACKGAMMON))
</MACRO>
<MACRO>
<NAME>GSGF_MOVE_BACKGAMMON_GET_CLASS</NAME>
#define GSGF_MOVE_BACKGAMMON_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GSGF_TYPE_MOVE_BACKGAMMON, GSGFMoveBackgammonClass))
</MACRO>
<STRUCT>
<NAME>GSGFMoveBackgammonClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFMoveBackgammon</NAME>
</STRUCT>
<STRUCT>
<NAME>GSGFMoveBackgammonClass</NAME>
struct _GSGFMoveBackgammonClass
{
        GSGFMoveClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_move_backgammon_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GSGFMoveBackgammon</NAME>
struct _GSGFMoveBackgammon
{
        GSGFMove parent_instance;
};
</STRUCT>
<FUNCTION>
<NAME>gsgf_move_backgammon_new</NAME>
<RETURNS>GSGFMoveBackgammon *</RETURNS>
void 
</FUNCTION>
<VARIABLE>
<NAME>filename</NAME>
extern char *filename;
</VARIABLE>
<VARIABLE>
<NAME>path</NAME>
extern char *path;
</VARIABLE>
<FUNCTION>
<NAME>test_collection</NAME>
<RETURNS>int </RETURNS>
GSGFCollection *collection, GError *error 
</FUNCTION>
<FUNCTION>
<NAME>expect_error</NAME>
<RETURNS>int </RETURNS>
GError *error, GError *expect 
</FUNCTION>
<FUNCTION>
<NAME>expect_error_conditional</NAME>
<RETURNS>int </RETURNS>
gboolean condition, const gchar *msg, GError *error, GError *expect 
</FUNCTION>
<FUNCTION>
<NAME>g_memory_stream_get_string</NAME>
<RETURNS>gchar *</RETURNS>
const GMemoryOutputStream *stream 
</FUNCTION>
<FUNCTION>
<NAME>build_filename</NAME>
<RETURNS>gchar *</RETURNS>
const gchar *filename 
</FUNCTION>
